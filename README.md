# Playground k8s cluster 
The following instructions lets you to create a local k8s cluster into your local machine using [kind](https://kind.sigs.k8s.io). 

The cluster configuration is **one master and 3 worker nodes**.

Before to start you need to install an updated version of the following CLI: `kind`, `kubectl`, and `helm`.

The cluster will includes the following base components:
- coredns (installed by default by kind)
- nginx ingress
- k8s dashboard

### TL;DR
Use `./create-cluster.sh` and `./delete-cluster.sh` scripts to respectively create and delete the `playground` cluster.

Creating the cluster takes less of 5 minutes on my Ubuntu 18.04 laptop: i7-4700HQ CPU @ 2.40GHz, 16GRam.

Then export the following variable to access your cluster using `kubectl` and `helm` commands.
```
export KUBECONFIG="$(kind get kubeconfig-path --name="playground")"
```
### Limitations
A cluster KIND uses the **docker in docker** technology to create a very light multi node cluster in your local machine. This is great to learn in deep more Kubernetes functionalities. 

But regrettably a KIND cluster is ephemeral. 

There is actually no solution to survive the cluster after a shutdown. There are no KIND commands to stop and restart the cluster neither. Also, stopping manually the docker containers of the KIND cluster to starting them back will not recover the good health of the KIND cluster. See [KIND issue #148](https://github.com/kubernetes-sigs/kind/issues/148).

Use **minikube** or **microk8s** alternatives if you need a non-ephemeral cluster. But keep in mind that these solutions are able to deploy a single node cluster only.

## 1. Create the cluster using Kind
The following command will create the playground k8S cluster with one master and 3 worker nodes.
```
$ kind create cluster --name playground --config ./kind.config
```

After creating a cluster, you can use `kubectl` to interact with it by using the configuration file generated by kind:
```
$ export KUBECONFIG="$(kind get kubeconfig-path --name="playground")"
$ kubectl cluster-info
$ kubectl get nodes -o wide
$ kubectl get all --all-namespaces
```

## 2. Initialize Helm 
`Tiller` is the server component for `helm`. `Tiller` will be present in the kubernetes cluster and the `helm` CLI talks to it for deploying applications using `helm charts`.
`Helm` will manage your cluster resources. So we need to add necessary permissions to the `tiller` components which will reside in the cluster `kube-system` namespace.

We need to:
- create a `service account` named `tiller`
- create a `ClusterRoleBinding` with cluster-admin permissions to the `tiller service account`

You start creating these resources using `kubectl`
```
$ kubectl apply -f ./helm/helm-rbac.yaml
```

Then you initialize `helm`. Doing so, a deployment named `tiller-deploy` will be deployed in the `kube-system` namespace.

Initialize `helm` using the following command.
```
$ helm init --service-account=tiller --history-max 300
```

You can check the tiller deployment in the `kube-system` namespace using `kubectl`.
```
$ kubectl -n kube-system get deployment tiller-deploy 
```

## 3. Adding Bitnami Helm Repository
Bitnami charts are carefully engineered, actively maintained and are the quickest and easiest way to deploy containers on a Kubernetes cluster. 
```
$ helm repo add bitnami https://charts.bitnami.com/bitnami
$ helm update
```
Be free to add others charts repositories following the previous similar instructions. [Helm Hub](https://hub.helm.sh/charts) is a web site listing most of the existing helm charts repositories.


## 4. Deploy Nginx Ingress using Helm
Execute the following `helm install` command to deploy an `nginx ingress` in the playground cluster inside the `nginx` namespace. 
```
$ helm install bitnami/nginx-ingress-controller --name ingress --namespace ingress \
-f ./nginx/nginx-values.yaml
```

## 5. Test ingress deploing the Hello-Kube using yaml (OPTIONAL)
Execute the following `kubectl apply` command to deploy `hello-kube` applications in the playground cluster. Three instances of the application will be created using a `replicaset` deployment.
```
$ kubectl apply -f ./hello-kube/hello-kube.yaml
```

After running `kubectl proxy`, use the following URL in your browser to access the `hello-kube` UI.
```
http://localhost:8001/api/v1/namespaces/default/services/hello-kube/proxy/
```

The following command will delete the `hello-kube` deployment.
```
$ kubectl delete -f ./hello-kube/hello-kube.yaml
```

## 6. Deploy Kubernetes Dashboard using Helm 
Execute the following `helm install` command to deploy the `kubertenes dashboard` in the playground cluster inside the `kube-system` namespace.
```
$ helm install stable/kubernetes-dashboard --name dashboard --namespace kube-system
```

The `tiller` `service account` has cluster-admin permissions, so we add its token to the `${KUBECONFIG}` file. This allows to use the `${KUBECOFIG}` file to login in the `kubertenes dashboard`.
```
TOKEN=$(kubectl -n kube-system describe secret tiller| awk '$1=="token:"{print $2}')
kubectl config set-credentials kubernetes-admin --token=${TOKEN}
```

Use port forwarding to access the `kubertenes dashboard` service in the cluster.
```
kubectl -n kube-system port-forward svc/dashboard-kubernetes-dashboard 8443:443
```

Then open your favorite browser using the following URL
```
https://localhost:8443
```


